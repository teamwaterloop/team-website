<div id="bbox" style="width:85%;height:70%" class="absolute-transform-center">
  <svg id="timeline" width="100%" height="100%"></svg>
</div>
<style>
  /* set the CSS */

  path {
    fill: none;
    stroke: #ffbf0f;
    stroke-width: 2px;
  }

  .dot {
    fill-opacity: 0;
    stroke-opacity: 0;
    stroke: #111111;
    fill: #FFF1CC;
    stroke-width: 3px;
  }

  .tooltip {
    position: absolute;
    text-align: center;
    padding: 5px 25px 5px 25px;
    margin: 3px;
    font-size: 14px;
    background: #fffbfd;
    border: 0px;
    border-radius: 8px;
    max-width: 200px;
    opacity: 0;
  }

  .tooltip p {
    margin: 0;
    padding: 0;
    font-family: 'proxima_nova_ltsemibold', 'Montserrat', Helvetica;
  }
  .line {
    transition: stroke-dashoffset 2s linear;
  }
  .dot {
    transition: fill-opacity 2s ease, stroke-opacity 2s ease;
  }
  .tooltip {
    transition: opacity 2s ease;
  }

  #he {
    font-size: 17px;
    padding-bottom: 2px;
  }
</style>

<!-- load the d3.js library -->
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>
!function() {

var dotRadius = 5;
var timeline = document.getElementById('timeline');

function makeLine(x, y) {
  return d3.line()
    .x(function (d) {
      return x(d.epoch);
    })
    .y(function (d) {
      return y(d.GNI);
    });
}

d3.csv("/timeline.csv", function(err, data) {
  if (err) throw err;
  function createScales(width, height) {
    var x = d3.scaleLinear().range([dotRadius + 2, width - dotRadius - 2]);
    var y = d3.scaleLinear().range([height - dotRadius - 2, dotRadius + 2]);
    x.domain(d3.extent(data, function (d) {
      return d.epoch;
    }));
    y.domain(d3.extent(data, function (d) {
      return d.GNI;
    }));
    return [x, y];
  }

  function draw() {
    var width = timeline.clientWidth;
    var height = timeline.clientHeight;
    // set the ranges
    var scales = createScales(width, height);
    var x = scales[0], y = scales[1];

    var svg = d3.select(timeline)
    var totalLength;
    var path = svg.append("path")
      .data([data])
      .attr("d", makeLine(x, y))
      .attr("stroke-dasharray", function(){ return totalLength = this.getTotalLength(); })
      .style("stroke-dashoffset", totalLength)

    // add the dots with tooltips
    var fixeddot = svg.selectAll()
      .data(data)
      .enter().append("circle")
      .attr("r", dotRadius)
      .attr("class", "dot")

    var bbox = d3.select(document.getElementById('bbox'));
    fixeddot
      .attr("cx", function (d) {
        return x(d.epoch);
      })
      .attr("cy", function (d) {
        return y(d.GNI);
      })
      .select(function (d) {
        var self = this;
        var dot = d3.select(self);
        dot.style("stroke","#ff7a09");
        var tooltip = bbox
          .append("div")
          .attr("class", "tooltip")
          .style("opacity", 0);
        tooltip.html("<p id=\"he\">" + d.term + "</p><p>" + d.info + "</p>")

        // position:
        // 0 | 2
        // --o--
        // 1 | 3
        // where `o` is the circle on the timeline
        var position = parseInt(d.position);
        var cy = parseFloat(self.getAttribute('cy'));
        var cx = parseFloat(self.getAttribute('cx'))

        if (position % 2 === 0) {
          tooltip.style("bottom", function () {
            return (1 - cy / height) * 100 + "%";
          });
        } else {
          tooltip.style("top", function () {
            return cy / height * 100 + "%";
          });
        }
        // ~~ is a faster Math.floor() (two bitwise nots converts it to integer)
        if (~~(position / 2) === 0) {
          tooltip.style("right", function () {
            return (1 - cx / width) * 100 + "%";
          })
        } else {
          tooltip.style("left", function () {
            return cx / width * 100 + "%";
          })
        }
        setTimeout(function() {
          dot.style("fill-opacity", 1).style("stroke-opacity", 1);
          tooltip.style("opacity", .9);
        }, 2000 * cx / width);
      });

    setTimeout(function() {
      path.attr("class", "line").style("stroke-dashoffset", 0);
    }, 0);
    // setTimeout(function() {
    //   fixeddot.style("fill-opacity", 1).style("stroke-opacity", 1);
    //   bbox.selectAll('.tooltip').style("opacity", .9);
    // }, 2000);

  }
  function redraw() {
    var width = timeline.clientWidth;
    var height = timeline.clientHeight;
    // set the ranges
    var scales = createScales(width, height);
    var x = scales[0], y = scales[1];
    // define the line
    var valueline = d3.line()
      .x(function (d) {
        return x(d.epoch);
      })
      .y(function (d) {
        return y(d.GNI);
      });
    var svg = d3.select(timeline);
    svg.select("path")
      .attr("d", valueline)
      .attr("stroke-dasharray", function(){ return this.getTotalLength() })
    svg.selectAll(".dot")
      .attr("cx", function (d) {
        return x(d.epoch);
      })
      .attr("cy", function (d) {
        return y(d.GNI);
      })
  }
  var drew = false;
  var animateHook = function () {
    var boundingRect = timeline.getBoundingClientRect();
    if (boundingRect.top >= 0 && boundingRect.bottom <= document.documentElement.clientHeight) {
      window.removeEventListener('scroll', animateHook);
      draw();
      drew = true;
    }
  }
  window.addEventListener('scroll', animateHook, false);
  window.addEventListener('resize', function() {
    if (drew) {
      redraw();
    }
  }, false);
});

}();
</script>
